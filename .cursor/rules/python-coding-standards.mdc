아래는 **1) 코드 스타일 & 정적 분석**, **2) 프로젝트 구조**에 **DDD 개념을 반영**해 최소 규칙만 담은 `.cursorrules` 초안입니다. 저장소 루트에 `.cursorrules`로 추가해 사용하십시오.

---

# `.cursorrules` (간략 + DDD 반영)

## 1) 코드 스타일 & 정적 분석

* 포맷: **black** (line-length 100)
* 정렬: **isort**(profile=black)
* 린트: **ruff** (flake8/pycodestyle 규칙 + import 정리)
* 타입체크: **mypy --strict** (공개 함수/메서드 타입힌트 필수)
* Docstring: **Google style**(프로젝트 전역 일관성 유지)
* 네이밍: 모듈/패키지 `snake_case`, 클래스 `PascalCase`, 상수 `UPPER_SNAKE_CASE`
* 금지: 와일드카드 import, 전역 가변 상태, 암묵적 I/O, 불필요한 싱글톤
* 실행 순서:

```bash
ruff check .
ruff format .   # or black .
mypy .
pytest -q
```

### DDD 정합성(정적 규칙)

* **계층 간 참조 방향**

  * `api → application → domain` (단방향)
  * `infra`는 **application/domain에 어댑터로 주입**되며, **domain을 직접 import하지 않음**(포트/프로토콜만 의존).
* **도메인 순수성**

  * `domain/`은 **표준 라이브러리 외 외부 라이브러리 의존 금지**.
  * 비즈니스 규칙은 **Entity/ValueObject/DomainService**에서만 구현.
* **경계 보호**

  * 서로 다른 **bounded context** 간 직접 참조 금지. 컨텍스트 간 통신은 **ACL(anti\_corruption)/application 서비스**를 통해 수행.
* **불변성**

  * 값 객체(Value Object)는 불변(`frozen=True` dataclass 등)으로 정의.
* **도메인 이벤트**

  * 상태 전이/중요 규칙은 **Domain Event**로 발행하고, 핸들러는 application 레이어에서 구독/조정.

## 2) 프로젝트 구조(DDD 반영 예시)

```
project_root/
  pyproject.toml
  src/
    <context_name>/                  # 각 Bounded Context 별 디렉터리 (예: lending/, investment/)
      api/                           # I/O 진입점 (FastAPI 라우터, gRPC 핸들러 등)
        routers/
      application/                   # Use case, 트랜잭션 경계, 서비스(오케스트레이션)
        services/
        dto/                         # 요청/응답/커맨드/쿼리 DTO
        ports/                       # 입력/출력 포트(Protocol)
        handlers/                    # 도메인 이벤트 -> 유스케이스 핸들러
      domain/                        # 순수 도메인
        entities/                    # Entity (ID, 동등성은 식별자 기반)
        value_objects/               # Value Object (불변)
        services/                    # Domain Service (규칙/정책)
        repositories/                # Repository 인터페이스(Protocol)
        specs/                       # Specification(검색/검증 규칙)
        events/                      # Domain Events
        errors.py                    # 도메인 예외(Validation, NotFound 등)
      infra/                         # 어댑터(Ports 구현)
        persistence/                 # Repository 구현(SQLAlchemy 등)
        external/                    # 외부 API 클라이언트
        messaging/                   # 메시지 브로커 어댑터
        acl/                         # 다른 컨텍스트/레거시 시스템 변환
      utils/                         # 범용 유틸(남용 금지)
  tests/
    unit/
    integration/
  scripts/
  docs/
```

### DDD 운용 규칙(핵심 체크리스트)

* **Use Case는 application 레이어**에서 시작하고 **트랜잭션 경계**를 가진다.
* **도메인 모델은 인프라를 모른다.** 영속성은 **Repository 인터페이스**로 추상화.
* **입출력 DTO**는 application 레이어에 두고, **도메인 객체를 직접 노출하지 않는다.**
* **사이드 이펙트**(DB/HTTP/메시징)는 **infra 어댑터**에서 처리하고 application으로 결과를 반환.
* **경계 간 모델 변환**은 `infra/acl/`에서 수행하여 **도메인 모델 오염 방지**.
* **도메인 이벤트**는 `domain/events`에서 정의, 발행은 도메인, 구독/오케스트레이션은 application.

### 간단 샘플(요지)

```python
# domain/value_objects/money.py
from dataclasses import dataclass

@dataclass(frozen=True, slots=True)
class Money:
    amount: int  # KRW
    def add(self, other: "Money") -> "Money":
        if other.amount < 0:
            raise ValueError("negative not allowed")
        return Money(self.amount + other.amount)
```

```python
# domain/repositories/order_repo.py
from typing import Protocol, Optional
from ..entities.order import Order

class OrderRepository(Protocol):
    def get(self, order_id: str) -> Optional[Order]: ...
    def save(self, order: Order) -> None: ...
```

```python
# application/services/place_order.py
from .ports.uow import UnitOfWork
from .dto.commands import PlaceOrderCmd
from ..domain.events import OrderPlaced

def place_order(cmd: PlaceOrderCmd, uow: UnitOfWork) -> str:
    with uow:                                  # 트랜잭션 경계
        order = uow.orders.new_from(cmd)       # 도메인 생성 로직 사용
        order.validate()                       # 도메인 규칙 검증
        uow.orders.save(order)
        uow.events.publish(OrderPlaced(order.id))
        return order.id
```

---